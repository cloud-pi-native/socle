---
- name: Create Argo CD infra namespace
  kubernetes.core.k8s:
    name: "{{ dsc.argocdInfra.namespace }}"
    api_version: v1
    kind: Namespace
    state: present

- name: Check admin password
  when: dsc.argocdInfra.admin.enabled
  block:
    - name: Get argocd-secret
      kubernetes.core.k8s_info:
        name: argocd-secret
        namespace: "{{ dsc.argocdInfra.namespace }}"
        kind: Secret
      register: argocd_secret

    - name: Warning message
      when: |
        (argocd_secret.resources | length == 0) and
        argoinfra_admin_password is not defined
      ansible.builtin.debug:
        msg: |
          "Attention ! Le déploiement de l'instance d'infra d'Argo CD nécessite le
          mot de passe admin lorsque le paramètre argocdInfra.admin.enabled
          est positionné sur true dans votre ressource de configuration dsc et que le
          secret argocd-secret est absent du namespace.

          Veuillez relancer l'installation en utilisant l'extra variable argoinfra_admin_password
          pour spécifier le mot de passe qui sera ensuite injecté dans le secret, exemple :

          ansible-playbook install-gitops.yaml -t argo-infra -e argoinfra_admin_password="mot_de_passe_ici"

          Pensez à noter ce mot de passe dans une applicaton sécurisée.
          "

    - name: Stop installation
      when: |
        (argocd_secret.resources | length == 0) and
        argoinfra_admin_password is not defined
      ansible.builtin.meta: end_play

- name: Set encrypted password
  when: dsc.argocdInfra.admin.enabled
  block:
    - name: Encrypt password
      changed_when: false
      ansible.builtin.shell:
        cmd: |
          set -o pipefail
          htpasswd -nbBC 10 "" "{{ argoinfra_admin_password }}" | tr -d ':\n' | sed 's/$2y/$2a/'
        executable: /bin/bash
      register: password_encryption

    - name: Set encrypted_password fact
      ansible.builtin.set_fact:
        encrypted_password: "{{ password_encryption.stdout }}"

- name: Get Argo CD client secret
  kubernetes.core.k8s_info:
    kind: Secret
    namespace: "{{ dsc.keycloakInfra.namespace }}"
    name: keycloak-client-secret-argoinfra-client
  register: argocd_secret
  failed_when: argocd_secret.resources | length == 0

# OpenShift CRB

- name: Argo CD OpenShift scc crb
  kubernetes.core.k8s:
    definition:
      apiVersion: rbac.authorization.k8s.io/v1
      kind: ClusterRoleBinding
      metadata:
        creationTimestamp:
        name: "{{ dsc_name }}-argo-infra-argocd-system:openshift:scc:privileged"
      roleRef:
        apiGroup: rbac.authorization.k8s.io
        kind: ClusterRole
        name: system:openshift:scc:privileged
      subjects:
        - kind: ServiceAccount
          namespace: "{{ dsc.argocdInfra.namespace }}"
          name: "{{ dsc_name }}-argo-infra-argocd-repo-server"
        - kind: ServiceAccount
          namespace: "{{ dsc.argocdInfra.namespace }}"
          name: argocd-server
        - kind: ServiceAccount
          namespace: "{{ dsc.argocdInfra.namespace }}"
          name: "{{ dsc_name }}-argo-infra-redis"
        - kind: ServiceAccount
          namespace: "{{ dsc.argocdInfra.namespace }}"
          name: "{{ dsc_name }}-argo-infra-redis-ha"
        - kind: ServiceAccount
          namespace: "{{ dsc.argocdInfra.namespace }}"
          name: "{{ dsc_name }}-argo-infra-redis-ha-haproxy"

- name: Add Argo CD helm repo
  changed_when: false
  kubernetes.core.helm_repository:
    name: argo
    repo_url: "{{ dsc.argocdInfra.helmRepoUrl }}"
    force_update: true

# Vault plugin setup

- name: Get Argo CD infra app version
  block:
    - name: Retrieve Argo CD Helm infos
      changed_when: false
      ansible.builtin.shell:
        cmd: |
          set -o pipefail
          helm search repo -l argo --version "{{ dsc.argocdInfra.chartVersion }}" | tail -n 1
        executable: /bin/bash
      register: argo_infos

    - name: Set argo_app_version fact
      ansible.builtin.set_fact:
        argo_app_version: "{{ argo_infos.stdout | regex_search('v([0-9]*\\.)+([0-9]+)') }}"

- name: Deploy Argo CD infra Vault plugin config
  kubernetes.core.k8s:
    template: "{{ item }}"
    state: present
  with_items:
    - vault-plugin-cm.yml.j2
    - vault-plugin-secret.yml.j2

# Registry setup

- name: Check registry secrets
  when: dsc.global.dockerAccount.enabled
  block:
    - name: Get helm-docker-registry-secret
      kubernetes.core.k8s_info:
        name: helm-docker-registry-secret
        namespace: "{{ dsc.argocdInfra.namespace }}"
        kind: Secret
      register: helm_docker_registry_secret

    - name: Get oci-dockerhub-creds secret
      kubernetes.core.k8s_info:
        name: oci-dockerhub-creds
        namespace: "{{ dsc.argocdInfra.namespace }}"
        kind: Secret
      register: oci_dockerhub_creds

    - name: Set missing_secret fact
      ansible.builtin.set_fact:
        missing_secret: false

    - name: Update missing_secret fact
      when:
        (helm_docker_registry_secret.resources | length == 0) or
        (oci_dockerhub_creds.resources | length == 0)
      ansible.builtin.set_fact:
        missing_secret: true

    - name: Warning message
      when: |
        (missing_secret is truthy and dockeruser is not defined) or
        (missing_secret is truthy and dockerpass is not defined)
      ansible.builtin.debug:
        msg: |
          "Attention ! Le déploiement de l'instance d'infra d'Argo CD nécessite les
          identifiants du compte docker lorsque le paramètre global.dockerAccount.enabled
          est positionné sur true dans votre ressource de configuration dsc et que l'un des
          secrets helm-docker-registry-secret ou oci_dockerhub_creds est absent du namespace.

          Veuillez relancer l'installation en utilisant les extra variables dockeruser et dockerpass
          pour spécifier les identifiants et générer les secrets, exemple :

          ansible-playbook install-gitops.yaml -t argo-infra -e dockeruser="utilisateur_ici" -e dockerpass="mot_de_passe_ici"
          "

    - name: Stop installation
      when: |
        (missing_secret is truthy and dockeruser is not defined) or
        (missing_secret is truthy and dockerpass is not defined)
      ansible.builtin.meta: end_play

- name: Deploy registry secrets
  when: |
    dsc.global.dockerAccount.enabled and
    missing_secret is truthy
  kubernetes.core.k8s:
    template: "{{ item }}"
    state: present
  with_items:
    - helm-docker-registry-secret.yml.j2
    - repo-creds.yml.j2

# Argo CD infra installation

- name: Find argo crd existence
  kubernetes.core.k8s_info:
    api_version: apiextensions.k8s.io/v1
    kind: CustomResourceDefinition
    name: applications.argoproj.io
  register: argocd_crd

- name: Set argocd_crd_present fact
  ansible.builtin.set_fact:
    argocd_crd_present: "{{ argocd_crd.resources | length > 0 | bool }}"

- name: Set path fact
  ansible.builtin.set_fact:
    path: "{{ role_path + '/templates/values' }}"

- name: Compute Argo CD Helm values
  ansible.builtin.include_role:
    name: combine
  vars:
    combine_path: "{{ path }}"
    combine_user_values: "{{ dsc.argocdInfra['values'] }}"
    combine_dest_var: "argo_values"

- name: Deploy helm
  kubernetes.core.helm:
    name: "{{ dsc_name }}-argo-infra"
    chart_ref: argo/argo-cd
    chart_version: "{{ dsc.argocdInfra.chartVersion }}"
    release_namespace: "{{ dsc.argocdInfra.namespace }}"
    create_namespace: true
    values: "{{ argo_values }}"

- name: Install routes
  kubernetes.core.k8s:
    template: "{{ item }}"
  with_items:
    - ingress.yaml.j2

# Alerting and monitoring setup

- name: Set alerting rules
  when: dsc.global.alerting.enabled
  kubernetes.core.k8s:
    template: prometheusrule.yml.j2

- name: Patch serviceMonitors
  when: >
    dsc.global.metrics.enabled and
    dsc.global.metrics.additionalLabels is defined
  block:
    - name: Get serviceMonitors
      kubernetes.core.k8s_info:
        api_version: monitoring.coreos.com/v1
        kind: ServiceMonitor
        namespace: "{{ dsc.argocdInfra.namespace }}"
      register: service_monitors

    - name: Get service_monitors names
      ansible.builtin.set_fact:
        service_monitors_names: "{{ service_monitors.resources | map(attribute='metadata.name') }}"

    - name: Patch serviceMonitors
      kubernetes.core.k8s:
        kind: ServiceMonitor
        namespace: "{{ dsc.argocdInfra.namespace }}"
        state: patched
        name: "{{ item }}"
        definition:
          metadata:
            labels: "{{ dsc.global.metrics.additionalLabels }}"
      loop: "{{ service_monitors_names }}"
